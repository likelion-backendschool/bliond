## 팀 구성원


[팀장] 김도율

[팀원] 박영승, 임채민, 허경주


<br>

---

<br>


### 새로 알게 된 점

### **Git**

☀️ 원격 저장소에 push한 commit 수정하기

1. `git rebase HEAD~[위치] -i`
    
    원하는 commit이 있는 위치까지 선택하여 rebase를 통해 commit을 수정할 수 있도록 한다.
    
2. 변경할 commit의 명령을 `pick` → `reword` 으로 변경하고 저장한다.
3. commit edit 창이 뜨면 commit을 수정한 후 저장한다.
4. `git remote origin push -f`
    
    push를 강제적으로 실행되도록 -f옵션을 붙여 실행한다.
    

☀️ Issue를 Git과 연결하기

1. Github의 issue 탭에서 issue를 생성한다.
2. 자동으로 생성된 issue의 번호를 포함하여 branch를 생성하여 push한다.
    
    이때 commit에 `#issue_number` 가 포함되어있으면 해당 issue와 연결된다.
    
3. `resolved #issue_number` 를 통해 issue를 close하거나, 해당 issue에서 close 버튼을 통해 끝낸다.

### Infra

- CGI에 대한 정리
    
    CGI 표준
    
    - 웹서버와 다른 프로그램들 간의 통신 규약
    
    톰캣 비표준
    
    - 자바에서만 유효한
    - 톰캣안에서만 유효한
    - POOL 개념이 녹아있다.
    
    NGINX -> CGI -> 자바프로그램
    

- PC 통신 종류
    - TCP_SOCKET (네트워크통신)
        - 전화 방식
        - 설정이 간편하다
    - UNIX_SOCKET 방식
        - 대화 방식(육성)
        - 같은 파일 시스템 내에서만 가능(= 같은 PC 내)
        

### **Query DSL**

- **@BeforeAll이 있는데 굳이 TestInitData를 만든 이유**
→ @BeforeAll은 각 테스트가 실행되기 전 딱 한 번 실행되는 어노테이션이다.
Question, Answer, User 테스트 클래스가 있으면 
각각 @BeforeAll을 세팅해주어야 하는데 
TestInitData에 몰아 넣으면 더 깔끔하게 관리하기 싶기 때문에 사용한다.

- **전체 회원 수 조회하기** ( count )
    
    ```java
    @Override
    public long getQslCount() {
        return jpaQueryFactory
                .select(siteUser.count())
                .from(siteUser)
                .fetchOne();
    }
    ```
    
- **가장 오래된 회원 1명 조회** ( orderBy, limit )
    
    ```java
    @Overfide
    public SiteUser getQslUserOrderByIdAscOne(){
    		
    		return jpaQueryFactory
    						.select(siteUser)
    						.from(siteUser)
    						.orderBy(siteUser.id.asc())
    						.limit(1)
    						.fetchOne();
    }
    ```
    
- **username, email로 검색** ( like )
    
    ```java
    @Override
    public List<SiteUser> searchQsl(String kw) {
    		return jpaQueryFactory
    						.select(siteUser)
    						.from(siteUser)
    						.where(
    								siteUser.username.like("%user1%")
    								.or(siteUser.email.like("%user%"))	
    						)
    						.fetch();
    }
    ```
    
<br>

---

<br>



### 어려웠던 점

- Infra 수업에서 로그인 과정에서 쿠키와 세션을 통해 사용자 정보를 저장하고 관리하는 것에 대해 다루었는데, 구현에 어려움이 있었다.
- QueryDSL 수업에서 InterestKeyword에 중간 테이블이란 개념이 잘 이해 가지 않았다.
- 고아 객체를 제거하거나 PK를 복합키로 변경하는 게 헷갈려서 다시 공부해야 될 거 같다.

<br>

---

<br>



### 아쉬운 점

## 회고 과정에서 나왔던 질문 (최소 200자 이상)


### 질문

1. 사용자 정보(로그인 정보)를 저장함에 있어 쿠키와 세션의 차이가 어떻게 되나요? 그렇다면 어떤 것을 선택하는 것이 좋을까요?
2. 멤버십 기능에 필요한 내용이 무엇일까요

<br>

### 답변

1. 쿠키는 클라이언트 측에 저장이 되고, 세션은 서버로 관리한다. 이로 인해 쿠키는 세션에 비해 보안에 취약하다. 하지만 속도에 있어서는 쿠키가 장점을 가지게 된다. 또한 세션은 서버에서 삭제하거나 브라우저를 종료할 시 정보가 삭제된다. 이에 반해 쿠키는 파일로 저장이 되어 브라우저를 종료해도 유지가 된다는 차이가 있다. 하지만 이 외에도 토큰을 사용하는 방식도 있어 jwt를 통한 구현을 고려하고 있다.

# 회원 가입과 로그인

회원 가입이란, 나의 정보를 등록하는 과정

로그인이란, 내가 누구인지 입증하는 과정

## 인증(Authentication)

보호된 리소스에 접근하는 것을 허용하기 이전에 등록된 유저의 신원을 입증(validation)하는 과정

## 인가(Authorization)

요청된 리소스에 접근할 수 있는 권한이 있는 인증(authenticated)된 유저인지 입증(validation)하는 과정

인증이 있고나서 인가가 있다.

인증되었지만 권한이 없다. == 인가 X

인가되었지만 인증은 되지 않았다. == 불가한 상황

# 웹에서의 인증/인가

## 1. 요청 헤더(request header)

URL에 포함된 아이디, 비밀번호 등을 브라우저가 Base64 인코더를 통하여 인코딩한 문자열을 요청 헤더 `Authorization` 에 넣어 로그인을 할 수 있다.

단점: 인증을 매번 해주어야 한다.

이제 브라우저의 스토리지의 힘을 빌려보자

## 2. 쿠키

브라우저의 로컬 스토리지에 저장된 쿠키를, 사용자가 인증이 필요한 요청을 할 때마다 요청 헤더에 실어서 보낸다. 

임의로 고치거나 지울 수 있고, 타인이 도용하거나 탈취도 쉽다. 따라서 민감하거나 중요한 정보를 쿠키에 저장하는 것은 적절하지 않다.

단점: 클라이언트는 서버에 비해 상대적으로 보안에 취약하다.

이제 서버의 힘을 빌려보자

## 3. 세션

사용자가 인증이 필요한 요청을 하게되면, 서버에서는 사용자의 식별자와 세션 세션 아이디를 파일로 저장한다. 서버는 응답 헤더에 세션아이디를 클라이언트에 보내게 된다(`Set-Cookie`). 세션에 로그인 정보를 갖고 있지만, 세션 아이디는 쿠키에 저장된다.

장점: 사용자의 low한 데이터를 클라이언트가 갖고 있지 않아도 된다. 세션의 만료 기한을 정할 수 있어 안전하다. 만약 탈취 되더라도, 서버에서 탈취된 정보를 삭제하게 되면 해당 세션 아이디는 사용을 못하게 된다.

단점1: 서비스가 커짐에 따라, 여러 서버를 두개 된 경우 + 각 서버에서 세션을 관리하는 경우 + 로드 밸런서가 있는 상황에서, 처음 세션 아이디가 발급 된 서버가 아닌 다른 곳에 요청이 들어오는 경우 boom

해결방법: 세션 스토리지를 두어 처리한다. 

단점2: 요청이 많아지는 경우 세션 스토리지가 터질 수 있다. (서버 부하 증가)

HTTP가 Stateless 하기 때문에 Stateful한 “인증, 인가”는 서로 패러다임의 충돌이 있다.

이젠 토큰의 힘, 정보의 요청과 응답에 한번 상태를 담아보자.

## 4. 토큰(feat. JWT)

JSON WEB TOKEN

시크릿 키를 통하여 JWT를 만들고, 인증 과정을 거친다. 하지만 디코딩하기 쉽다.

하지만 쿠키와 마찬가지로 민감한 정보는 담으면 안된다.

장점: 서버가 여러대라도 서버 각각의 시크릿 키를 통하여 해독할 수 있다.

단점: 엑세스 토큰이 탈취되기 쉽다.

해결방법: 만료 기한을 설정한다. + 리프레쉬 토큰

첫 요청이 들어오면 엑세스 토큰과 리프레시 토큰을 동시에 발급하고 클라이언트에 보낸다. DB에는 리프레시 토큰만 저장한다.

엑세스 토큰이 만료가 된다면 서버는 만료되었다는 응답을 보내면, 클라이언트에서는 엑세스 토큰과 리프레시 토큰을 서버에 보내고, DB의 리프레시 토큰과 매칭 후 갱신한 엑세스 토큰을 클라이언트에 보내게 된다.

토큰으로 상태관리를 하기 때문에 세션을 따로 둘 필요가 없지만 같이 쓰기도 한다.

리프레시 토큰 + 슬라이딩 세션..?

## 5. OAuth

다른 웹사이트 상의 자신들의 정보에 대해 접근 권한을 부여할 수 있는 공통적인 수단, 개방형 표준

### 용어

- 리소스 소유자: 보호된 리소스에 대한 접근을 허용할 수 있는 엔티티(유저)
- 리소스 서버: 보호된 리소스를 호스트하고 액세스 요청을 처리하는 서버
- 클라이언트: 리소스 서버에 액세스 하여 리소스 소유자를 대신하여 작업을 수행하려는 응용 프로그램
- 인증 서버: 리소스 소유자를 알고 있으며 클라이언트에 리소스 서버에 액세스할 수 있는 권한을 부여할 수 있는 서버

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/5eea1ab6-3a49-4318-9bb9-f21c0880bfad/Untitled.png)

클라이언트가 OAuth를 사용하여 리소스 소유자를 대신하여 자격 증명 없이 리소스 서버에 액세스 할 수 있게 된다.

위 그림의 과정을 살펴보면

1. 클라이언트는 리소스 소유자(유저)에게 액세스 권한을 요청한다.
2. 유저는 클라이언트에 권한을 부여한다.
3. 클라이언트는 인증 서버에 권한 부여를 인증한다.
4. 인증 서버는 클라이언트에 엑세스 토큰을 발급한다.
5. 클라이언트는 리소스 서버에 엑세스 토큰으로 리소스를 요청한다.
6. 리소스 서버는 보호된 리소스를 전달한다.


<br>

---

<br>




## 회고 인증샷 & 팀 자랑



- 필수) 팀원들과 함께 찍은 인증샷(온라인 만남시 스크린 캡쳐)도 함께 업로드 해주세요 🙂
- 필수) 자랑 멘트는 **‘팀 내에서 어떻게 복습을 하고 있고, 해당 복습 과정으로 인해 어떤 긍정적인 효과가 발생했는지’**에 대해 간단하게 작성해 주시면 됩니다 😊

### 인증샷

![Untitled (4)](https://user-images.githubusercontent.com/27273017/189508565-abfddd01-e87b-46f5-a878-476431487c57.png)


<br>

---

<br>



### 자랑 멘트

김도율: 저희팀은 취직 성공자를 배출한 팀입니다.

임채민 : 강민님 취업 축하드립니다!! 거기서도 잘 해내실 거예요! 👏👏

허경주 :  취업을 하며 떠나신 강민님… 행복하세요!! 취뽀 축하드립니다!!!  🎉

박영승: 강민님 취뽀 축하드립니다!!!
